#!/usr/bin/env python

# Grabs the latest members data from data.parliament XML and update accordingly.
# Get data using crawl-datadotparl-members.py

from collections import OrderedDict
import json
import re
from lxml import etree
from datetime import datetime

# Source XML files to use for the list of members
source_files = [
  'all-current-commons'
]

parser = etree.ETCompatXMLParser()
etree.set_default_parser(parser)


def slugify(s):
    return re.sub('[^\w ]', '', s).replace(' ', '-').lower()


class Popolo(object):
    def __init__(self):
        self.organizations = []
        self.memberships = []

    def output(self, fn):
        self.memberships = sorted(self.memberships, key=lambda x: (x['person_id'], x['id']))
        self.organizations = sorted(self.organizations, key=lambda x: x['id'])
        out = OrderedDict(sorted({
            'organizations': self.organizations,
            'memberships': self.memberships,
        }.items()))
        json.dump(out, open('../members/ministers-2010.json', 'w'), indent=2)

    def add_membership(self, mship):
        self.memberships.append(mship)

    def add_organization(self, org, id=None, **kwargs):
        id = id or slugify(org)
        org = OrderedDict(sorted({'id': id, 'name': org}.items()))
        org.update(kwargs)
        if org not in self.organizations:
            self.organizations.append(org)
        return id

popolo = Popolo()


class TimePeriod(object):
  def __init__(self, el):
    self.el = el

  def make_date(self, s):
    return datetime.strptime(self.el.find(s).text, '%Y-%m-%dT00:00:00').strftime('%Y-%m-%d')

  @property
  def dates(self):
    start = self.make_date('StartDate')
    end = self.make_date('EndDate') if self.el.find('EndDate').text else '9999-12-31'
    return start, end


class Position(object):
  def __init__(self, position, positions):
    self.position = position
    self.list = positions

  @property
  def time_periods(self):
    position = self.position
    attrs = {}
    if self.list.name_is_dept:
      attrs['position'] = ''
    elif position.find('HansardName').text is not None:
      attrs['position'] = position.find('HansardName').text
    else:
      attrs['position'] = position.find('Name').text
    position_dates = TimePeriod(self.position).dates
    attrs['fromdate'], attrs['todate'] = position_dates
    periods = [ attrs ]
    chairdates = position.find('ChairDates')
    if chairdates is None or not len(chairdates):
      return periods
    if len(chairdates) > 1:
      raise Exception("Doesn't currently handle more than one chair date, one was bad enough!")
    chair_dates = TimePeriod(chairdates.find('ChairDate')).dates
    if chair_dates[0] <= position_dates[0]:
      attrs['position'] = 'Chair'
      if chair_dates[1] < position_dates[1]:
        attrs['todate'] = chair_dates[1]
        periods.append({'position': '', 'fromdate': chair_dates[1], 'todate': position_dates[1]})
    else:
      attrs['todate'] = chair_dates[0]
      if chair_dates[1] < position_dates[1]:
        periods.append({'position': 'Chair', 'fromdate': chair_dates[0], 'todate': chair_dates[1]})
        periods.append({'position': '', 'fromdate': chair_dates[1], 'todate': position_dates[1]})
      else:
        periods.append({'position': 'Chair', 'fromdate': chair_dates[0], 'todate': position_dates[1]})
    return periods

  def generate(self):
    position = self.position
    for period in self.time_periods:
      attrs = OrderedDict()
      attrs['id'] = 'uk.parliament.data/Member/%s/%s/%s%s' % (
        self.list.person['datadotparl_id'], self.list.typ, position.attrib['Id'], self.counter)
      attrs['source'] = 'datadotparl/%s' % self.list.typ.lower()
      if self.list.name_is_dept:
          dept = position.find('Name').text
          if not re.search('panel|committee|commission|court(?i)', dept):
              dept = '%s Committee' % dept
      else:
          dept = ''
      if period['position']:
          attrs['role'] = period['position']
      attrs['person_id'] = self.list.person['id']
      # XXX Will need to cover Lords etc at some point
      attrs['organization_id'] = popolo.add_organization(dept or 'House of Commons')
      attrs['start_date'] = period['fromdate']
      if period['todate'] != '9999-12-31':
          attrs['end_date'] = period['todate']
      popolo.add_membership(attrs)

  @property
  def counter(self):
    extra = ''
    id = self.position.attrib['Id']
    if self.list.counter.setdefault(id, 0):
      extra = '/%d' % self.list.counter[id]
    self.list.counter[id] += 1
    return extra


class Positions(object):
  def __init__(self, data, person):
    self.data = data
    self.person = person

  def filter(self, typ, name_is_dept=False):
    container = typ + 's'
    if self.data.find(container) is None:
      return
    self.counter = {}
    self.typ = typ
    self.name_is_dept = name_is_dept
    for p in self.data.find(container).findall(typ):
      pos = Position(p, self)
      yield pos


def parse(fn, root_tag):
  try:
    xml = etree.parse(fn).getroot()
  except:
    raise Exception('Data from %s does not seem to be valid XML.' % fn)
  if xml.tag != root_tag:
    raise Exception('Root tag in %s is not "%s" as expected, got "%s"' % (fn, root_tag, xml.tag))
  return xml


for source_file in source_files:
  parl_members_slim = parse('../rawdata/datadotparl/' + source_file + '.xml', 'Members')
  print 'Found ' + str(len(parl_members_slim)) + ' members from ' + source_file + '.xml.'

  # Enrich the data!
  parl_members = dict()
  for member in parl_members_slim:
    member_fullbio_xml = parse('../rawdata/datadotparl/' + member.attrib['Member_Id'] + '.xml', 'Members')
    parl_members[member.attrib['Member_Id']] = member_fullbio_xml.find('Member')

  ##########
  # At this point parl_members contains a complete set of data.
  ##########

  # Import people.xml
  people_json = json.load(open('../members/people.json'))
  people = []
  for person in people_json['persons']:
    for i in person.get('identifiers', []):
      if i['scheme'] == 'datadotparl_id':
        person['datadotparl_id'] = i['identifier']
        people.append(person)
  print str(len(people)) + ' people with data.parliament ID.'

  for person in people:
    parl_data = parl_members[person['datadotparl_id']]
    positions = Positions(parl_data, person)

    for position in positions.filter('GovernmentPost'):
      position.generate()
    for position in positions.filter('OppositionPost'):
      position.generate()
    for position in positions.filter('ParliamentaryPost'):
      position.generate()
    for position in positions.filter('Committee', name_is_dept=True):
      position.generate()

  print 'Done for ' + source_file + '.xml.'

# Write out the updated ministers file
popolo.output('../members/ministers-2010.json')
print 'ministers-2010.json updated!'

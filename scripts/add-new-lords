#!/usr/bin/env python

import json
import re
import urllib2
from lxml import etree
from popolo import Popolo
from popolo.utils import new_id

parser = etree.ETCompatXMLParser()
etree.set_default_parser(parser)

data = Popolo()

parl_ids = {}
for person in data.persons.values():
    for i in person.get('identifiers', []):
        if i['scheme'] == 'datadotparl_id':
            parl_ids[person['id']] = i['identifier']


def canon_name(n):
    n = re.sub(' St\. +', ' St ', n)
    n = re.sub('^The ', '', n)
    n = re.sub(' De ', ' de ', n)
    n = re.sub('Lord (Archb|B)ishop ', r'\1ishop ', n)
    return n


LORDS_URL = 'http://data.parliament.uk/membersdataplatform/services/mnis/members/query/house=Lords/BasicDetails'
parl_members = etree.parse(urllib2.urlopen(LORDS_URL)).getroot()

lord_match = re.compile('^([^\s]*)\s+(.*?)(?:\s+of\s+(.*))?$')

party_map = {
    'Liberal Democrats': 'liberal-democrat',
    'Conservative': 'conservative',
    'Crossbench': 'crossbench',
    'Labour': 'labour',
    'Green Party': 'green',
    'Bishops': 'bishop',
    'Democratic Unionist Party': 'dup',
    'Non-affiliated': 'non-affiliated'
}

type_map = {
    'Life peer': 'L',
    'Excepted Hereditary': 'HP',
    'Bishops': 'B'
}

changed = False
parl_by_name = {}
person_id = data.max_person_id()
for member in parl_members:
    name = member.find('DisplayAs').text
    end_date = member.find('HouseEndDate').text or ''
    end_date = end_date.replace('T00:00:00', '')
    if end_date and end_date < '1999-11-12':
        continue
    canonical_name = canon_name(name)
    if member.attrib['Pims_Id'] not in data.identifiers['pims_id'] or member.attrib['Member_Id'] not in data.identifiers['datadotparl_id']:
        print "{} may be a new Lord".format(name)
        person_id = new_id(person_id)
        lord_id = new_id(data.max_lord_id())
        print person_id

        given_name = member.find('BasicDetails/GivenForename').text
        middle_names = member.find('BasicDetails/GivenMiddleNames').text
        surname = member.find('BasicDetails/GivenSurname').text

        lord_type = type_map[member.find('MemberFrom').text]
        party = party_map[member.find('Party').text]
        start_date = re.sub('T.*$', '', member.find('HouseStartDate').text)

        if lord_type == 'B':
            prefix, of, lordof = canonical_name.split(' ')
            if middle_names:
                given_name = '{} {} {}'.format(
                    given_name, middle_names, surname)
            else:
                given_name = '{} {}'.format(given_name, surname)
            name = {
                "given_name": given_name,
                "honorific_prefix": prefix,
                "lordname": "",
                "lordofname": lordof,
                "note": "Main"
            }
        else:
            title_parts = lord_match.search(name)
            prefix = title_parts.group(1)
            lordname = title_parts.group(2)
            lordof = title_parts.group(3) or ''
            name = {
                'given_name': given_name,
                'honorific_prefix': prefix,
                'lordname': lordname,
                'lordofname': lordof,
                'start_date': '',
                'note': 'Main',
            }
            if middle_names:
                name['additional_name'] = middle_names
            if surname and surname != lordname:
                name['surname'] = surname

        ids = [
            {
                'scheme': 'pims_id',
                'identifier': member.attrib['Pims_Id']
            }
        ]
        if member.attrib['Member_Id']:
            ids.append({
                    'scheme': 'datadotparl_id',
                    'identifier': member.attrib['Member_Id']
                })

        person = {
            'id': person_id,
            'identifiers': ids,
            'other_names': [name]
        }

        membership = {
            'id': lord_id,
            'identifiers': [{
                'identifier': lord_type,
                'scheme': 'peeragetype'
            }],
            'label': 'Peer',
            'on_behalf_of_id': party,
            'organization_id': 'house-of-lords',
            'person_id': person_id,
            'role': 'Peer',
            'start_date': start_date
        }

        if not membership['start_date'] or not membership['on_behalf_of_id']:
            sys.exit()

        print json.dumps(person, indent=4)
        print json.dumps(membership, indent=4)
        response = raw_input('Add new lord? (Y/n) ')
        if response != 'n':
            data.add_person(person)
            data.add_membership(membership)
            changed = True
            print "Added."
    elif not data.get_person(name=canonical_name):
        existing_person = data.identifiers['pims_id'][member.attrib['Pims_Id']]
        print "{} is a known person who may be a new Lord ({}, {})".format(name, member.attrib['Pims_Id'], existing_person['id'])

        existing_lord_id = new_id(data.max_lord_id())

        given_name = member.find('BasicDetails/GivenForename').text
        middle_names = member.find('BasicDetails/GivenMiddleNames').text
        surname = member.find('BasicDetails/GivenSurname').text

        title_parts = lord_match.search(member.find('DisplayAs').text)
        prefix = title_parts.group(1)
        lordname = title_parts.group(2)
        lordof = title_parts.group(3) or ''

        lord_type = type_map[member.find('MemberFrom').text]
        party = party_map[member.find('Party').text]
        start_date = re.sub('T.*$', '', member.find('HouseStartDate').text)

        name = {
            "given_name": given_name,
            "honorific_prefix": prefix,
            "lordname": lordname,
            "lordofname": lordof,
            "lordofname_full": "",
            "county": "",
            "start_date": start_date,
            "note": "Main"
        }
        if middle_names:
            name['additional_name'] = middle_names
        if surname and surname != lordname:
            name['surname'] = surname
        membership = {
            "id": existing_lord_id,
            "identifiers": [{
              "identifier": lord_type,
              "scheme": "peeragetype"
            }],
            "label": "Peer",
            "on_behalf_of_id": party,
            "organization_id": "house-of-lords",
            "person_id": existing_person['id'],
            "role": "Peer",
            "start_date": start_date
        }
        print json.dumps(name, indent=4)
        print json.dumps(membership, indent=4)
        response = raw_input('Add new lord? (Y/n) ')
        if response != 'n':
            for other_name in existing_person['other_names']:
                other_name['end_date'] = start_date
            existing_person['other_names'].append(name)
            data.add_membership(membership)
            changed = True
            print "Added."

if changed:
    data.dump()
